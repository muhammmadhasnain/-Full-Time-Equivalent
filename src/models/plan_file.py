"""
Plan file model for AI Employee Foundation
Represents a plan generated by Claude Code based on an action file
"""
import uuid
import sys
from datetime import datetime
from typing import Dict, Any, List, Optional
from pathlib import Path
import yaml
import re

# Add the src directory to the path so we can import modules
current_dir = Path(__file__).parent
src_dir = current_dir.parent
if str(src_dir) not in sys.path:
    sys.path.insert(0, str(src_dir))

from lib.utils import validate_uuid, get_current_iso_timestamp
from lib.exceptions import PlanFileError, ValidationError
from lib.constants import PLAN_STATUSES


class PlanFile:
    """
    Represents a plan file in the AI Employee system.
    Plan files are created by Claude Code based on action files and placed in the /Plans folder.
    """
    
    def __init__(
        self,
        action_id: str,
        plan_id: str = None,
        status: str = "draft",
        created_at: str = None,
        updated_at: str = None,
        estimated_duration: int = None,
        dependencies: List[str] = None,
        objectives: str = "",
        steps: str = "",
        resources: str = "",
        success_criteria: str = "",
        **kwargs
    ):
        """
        Initialize a PlanFile instance.
        
        Args:
            action_id: Reference to the originating action (UUID)
            plan_id: Unique identifier for the plan (UUID)
            status: Current status of the plan (draft, planned, approved, executed, cancelled)
            created_at: Creation timestamp
            updated_at: Last update timestamp
            estimated_duration: Estimated completion time in minutes
            dependencies: List of related action IDs
            objectives: What needs to be accomplished
            steps: Detailed action steps
            resources: Required tools, files, or information
            success_criteria: How to verify completion
        """
        self.action_id = action_id
        self.id = plan_id or str(uuid.uuid4())
        self.status = status
        self.created_at = created_at or get_current_iso_timestamp()
        self.updated_at = updated_at or get_current_iso_timestamp()
        self.estimated_duration = estimated_duration
        self.dependencies = dependencies or []
        self.objectives = objectives
        self.steps = steps
        self.resources = resources
        self.success_criteria = success_criteria
        
        # Store any additional properties
        for key, value in kwargs.items():
            setattr(self, key, value)
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'PlanFile':
        """
        Create a PlanFile instance from a dictionary.
        
        Args:
            data: Dictionary containing plan file data
            
        Returns:
            PlanFile instance
        """
        # Extract frontmatter data
        frontmatter = data.get('frontmatter', {})
        
        # Validate required fields
        action_id = frontmatter.get('action_id')
        if not action_id or not validate_uuid(action_id):
            raise ValidationError(f"Invalid or missing action_id: {action_id}")
        
        # Validate status
        status = frontmatter.get('status', 'draft')
        if status not in PLAN_STATUSES:
            raise ValidationError(f"Invalid status: {status}. Valid statuses: {PLAN_STATUSES}")
        
        # Validate plan ID if provided
        plan_id = frontmatter.get('plan_id') or frontmatter.get('id')
        if plan_id and not validate_uuid(plan_id):
            raise ValidationError(f"Invalid plan_id: {plan_id}")
        
        # Extract body content
        body = data.get('body', '')
        sections = cls._parse_body_content(body)
        
        return cls(
            action_id=action_id,
            plan_id=plan_id,
            status=status,
            created_at=frontmatter.get('created_at'),
            updated_at=frontmatter.get('updated_at'),
            estimated_duration=frontmatter.get('estimated_duration'),
            dependencies=frontmatter.get('dependencies', []),
            objectives=sections.get('objectives', ''),
            steps=sections.get('steps', ''),
            resources=sections.get('resources', ''),
            success_criteria=sections.get('success_criteria', ''),
        )
    
    @classmethod
    def from_file(cls, file_path: str) -> 'PlanFile':
        """
        Create a PlanFile instance from a Markdown file with YAML frontmatter.
        
        Args:
            file_path: Path to the plan file
            
        Returns:
            PlanFile instance
        """
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Split frontmatter and body
            parts = re.split(r'^---\s*$', content, maxsplit=2, flags=re.MULTILINE)
            
            if len(parts) < 3:
                raise PlanFileError(f"Plan file {file_path} does not contain valid YAML frontmatter")
            
            # Parse frontmatter
            frontmatter_str = parts[1]
            try:
                frontmatter = yaml.safe_load(frontmatter_str)
                if frontmatter is None:
                    frontmatter = {}  # Handle empty frontmatter
            except yaml.YAMLError as e:
                raise PlanFileError(f"Invalid YAML frontmatter in plan file {file_path}: {str(e)}")
            
            # The body is everything after the second --- marker
            body = parts[2]
            
            # Combine into a single data structure
            data = {
                'frontmatter': frontmatter,
                'body': body
            }
            
            return cls.from_dict(data)
        except FileNotFoundError:
            raise PlanFileError(f"Plan file not found: {file_path}")
        except Exception as e:
            raise PlanFileError(f"Error loading plan file {file_path}: {str(e)}")
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Convert the PlanFile instance to a dictionary with frontmatter and body.
        
        Returns:
            Dictionary with 'frontmatter' and 'body' keys
        """
        frontmatter = {
            'action_id': self.action_id,
            'id': self.id,
            'status': self.status,
            'created_at': self.created_at,
            'updated_at': self.updated_at,
        }
        
        # Add optional fields only if they have values
        if self.estimated_duration is not None:
            frontmatter['estimated_duration'] = self.estimated_duration
        if self.dependencies:
            frontmatter['dependencies'] = self.dependencies
        
        # Construct the body content
        body_parts = []
        if self.objectives:
            body_parts.append(f"# Objectives\n{self.objectives}")
        if self.steps:
            body_parts.append(f"\n# Steps\n{self.steps}")
        if self.resources:
            body_parts.append(f"\n# Resources\n{self.resources}")
        if self.success_criteria:
            body_parts.append(f"\n# Success Criteria\n{self.success_criteria}")
        
        body = "\n".join(body_parts).strip()
        
        return {
            'frontmatter': frontmatter,
            'body': body
        }
    
    def to_markdown(self) -> str:
        """
        Convert the PlanFile instance to a Markdown string with YAML frontmatter.
        
        Returns:
            Markdown string with YAML frontmatter
        """
        data = self.to_dict()
        
        # Format frontmatter as YAML
        frontmatter_yaml = yaml.dump(data['frontmatter'], default_flow_style=False, allow_unicode=True).strip()
        
        # Combine with body
        markdown_content = f"---\n{frontmatter_yaml}\n---\n\n{data['body']}"
        
        return markdown_content
    
    def save_to_file(self, file_path: str) -> None:
        """
        Save the PlanFile instance to a Markdown file with YAML frontmatter.
        
        Args:
            file_path: Path where the plan file should be saved
        """
        try:
            # Ensure the directory exists
            Path(file_path).parent.mkdir(parents=True, exist_ok=True)
            
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(self.to_markdown())
        except Exception as e:
            raise PlanFileError(f"Error saving plan file {file_path}: {str(e)}")
    
    def validate(self) -> bool:
        """
        Validate the plan file data.
        
        Returns:
            True if valid, raises ValidationError if invalid
        """
        if not validate_uuid(self.action_id):
            raise ValidationError(f"Invalid UUID for action_id: {self.action_id}")
        
        if not validate_uuid(self.id):
            raise ValidationError(f"Invalid UUID for plan id: {self.id}")
        
        if self.status not in PLAN_STATUSES:
            raise ValidationError(f"Invalid status: {self.status}. Valid statuses: {PLAN_STATUSES}")
        
        if not self.created_at:
            raise ValidationError("created_at is required")
        
        if not self.updated_at:
            raise ValidationError("updated_at is required")
        
        # Validate timestamps
        try:
            datetime.fromisoformat(self.created_at.replace("Z", "+00:00"))
            datetime.fromisoformat(self.updated_at.replace("Z", "+00:00"))
        except ValueError:
            raise ValidationError(f"Invalid timestamp format")
        
        # Validate dependencies are valid UUIDs
        for dep_id in self.dependencies:
            if not validate_uuid(dep_id):
                raise ValidationError(f"Invalid UUID in dependencies: {dep_id}")
        
        # Validate required sections are present
        if not self.objectives.strip():
            raise ValidationError("Objectives section is required")
        
        if not self.steps.strip():
            raise ValidationError("Steps section is required")
        
        if not self.success_criteria.strip():
            raise ValidationError("Success Criteria section is required")
        
        return True
    
    @staticmethod
    def _parse_body_content(body: str) -> Dict[str, str]:
        """
        Parse the body content to extract different sections.
        
        Args:
            body: Raw body content of the plan file
            
        Returns:
            Dictionary with section names as keys and content as values
        """
        sections = {
            'objectives': '',
            'steps': '',
            'resources': '',
            'success_criteria': ''
        }
        
        # Split the body into lines
        lines = body.split('\n')
        
        current_section = None
        for line in lines:
            # Check if this line is a section header
            if line.strip().startswith('# Objectives'):
                current_section = 'objectives'
            elif line.strip().startswith('# Steps'):
                current_section = 'steps'
            elif line.strip().startswith('# Resources'):
                current_section = 'resources'
            elif line.strip().startswith('# Success Criteria'):
                current_section = 'success_criteria'
            else:
                # If we're in a section, add the line to that section
                if current_section and line.strip():
                    if sections[current_section]:
                        sections[current_section] += '\n' + line
                    else:
                        sections[current_section] = line.lstrip()
        
        return sections
    
    def __repr__(self) -> str:
        """String representation of the PlanFile."""
        return f"PlanFile(id={self.id}, action_id={self.action_id}, status={self.status})"
    
    def __eq__(self, other) -> bool:
        """Check equality with another PlanFile."""
        if not isinstance(other, PlanFile):
            return False
        return self.id == other.id